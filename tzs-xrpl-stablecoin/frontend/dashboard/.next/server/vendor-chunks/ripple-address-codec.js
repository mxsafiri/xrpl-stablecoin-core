"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ripple-address-codec";
exports.ids = ["vendor-chunks/ripple-address-codec"];
exports.modules = {

/***/ "(ssr)/./node_modules/ripple-address-codec/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst assert = __importStar(__webpack_require__(/*! assert */ \"assert\"));\nconst xrp_codec_1 = __webpack_require__(/*! ./xrp-codec */ \"(ssr)/./node_modules/ripple-address-codec/dist/xrp-codec.js\");\nObject.defineProperty(exports, \"codec\", ({ enumerable: true, get: function () { return xrp_codec_1.codec; } }));\nObject.defineProperty(exports, \"encodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } }));\nObject.defineProperty(exports, \"decodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } }));\nObject.defineProperty(exports, \"encodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } }));\nObject.defineProperty(exports, \"decodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } }));\nObject.defineProperty(exports, \"encodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } }));\nObject.defineProperty(exports, \"decodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } }));\nObject.defineProperty(exports, \"encodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } }));\nObject.defineProperty(exports, \"decodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } }));\nObject.defineProperty(exports, \"isValidClassicAddress\", ({ enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } }));\nconst PREFIX_BYTES = {\n    // 5, 68\n    main: Buffer.from([0x05, 0x44]),\n    // 4, 147\n    test: Buffer.from([0x04, 0x93]),\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n    return encodeXAddress(accountId, tag, test);\n}\nexports.classicAddressToXAddress = classicAddressToXAddress;\nfunction encodeXAddress(accountId, tag, test) {\n    if (accountId.length !== 20) {\n        // RIPEMD160 is 160 bits = 20 bytes\n        throw new Error('Account ID must be 20 bytes');\n    }\n    if (tag > MAX_32_BIT_UNSIGNED_INT) {\n        throw new Error('Invalid tag');\n    }\n    const theTag = tag || 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n    const flag = tag === false || tag == null ? 0 : 1;\n    /* eslint-disable no-bitwise ---\n     * need to use bitwise operations here */\n    const bytes = Buffer.concat([\n        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n        accountId,\n        Buffer.from([\n            // 0x00 if no tag, 0x01 if 32-bit tag\n            flag,\n            // first byte\n            theTag & 0xff,\n            // second byte\n            (theTag >> 8) & 0xff,\n            // third byte\n            (theTag >> 16) & 0xff,\n            // fourth byte\n            (theTag >> 24) & 0xff,\n            0,\n            0,\n            0,\n            // four zero bytes (reserved for 64-bit tags)\n            0,\n        ]),\n    ]);\n    /* eslint-enable no-bitwise */\n    return xrp_codec_1.codec.encodeChecked(bytes);\n}\nexports.encodeXAddress = encodeXAddress;\nfunction xAddressToClassicAddress(xAddress) {\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const { accountId, tag, test } = decodeXAddress(xAddress);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n    return {\n        classicAddress,\n        tag,\n        test,\n    };\n}\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\nfunction decodeXAddress(xAddress) {\n    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const test = isBufferForTestAddress(decoded);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const accountId = decoded.slice(2, 22);\n    const tag = tagFromBuffer(decoded);\n    return {\n        accountId,\n        tag,\n        test,\n    };\n}\nexports.decodeXAddress = decodeXAddress;\nfunction isBufferForTestAddress(buf) {\n    const decodedPrefix = buf.slice(0, 2);\n    if (PREFIX_BYTES.main.equals(decodedPrefix)) {\n        return false;\n    }\n    if (PREFIX_BYTES.test.equals(decodedPrefix)) {\n        return true;\n    }\n    throw new Error('Invalid X-address: bad prefix');\n}\nfunction tagFromBuffer(buf) {\n    const flag = buf[22];\n    if (flag >= 2) {\n        // No support for 64-bit tags at this time\n        throw new Error('Unsupported X-address');\n    }\n    if (flag === 1) {\n        // Little-endian to big-endian\n        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n    }\n    assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');\n    assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');\n    return false;\n}\nfunction isValidXAddress(xAddress) {\n    try {\n        decodeXAddress(xAddress);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidXAddress = isValidXAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsZ0NBQWdDLEdBQUcsc0JBQXNCLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUMvWSw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN6Qyx5Q0FBd0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDN0csOENBQTZDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3ZILDhDQUE2QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN2SCxtREFBa0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDakksbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLG9EQUFtRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNuSSxvREFBbUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbkksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSx5REFBd0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3hycGwtc3RhYmxlY29pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC9pbmRleC5qcz84NTU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVmFsaWRYQWRkcmVzcyA9IGV4cG9ydHMuZGVjb2RlWEFkZHJlc3MgPSBleHBvcnRzLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyA9IGV4cG9ydHMuZW5jb2RlWEFkZHJlc3MgPSBleHBvcnRzLmNsYXNzaWNBZGRyZXNzVG9YQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENsYXNzaWNBZGRyZXNzID0gZXhwb3J0cy5kZWNvZGVBY2NvdW50UHVibGljID0gZXhwb3J0cy5lbmNvZGVBY2NvdW50UHVibGljID0gZXhwb3J0cy5kZWNvZGVOb2RlUHVibGljID0gZXhwb3J0cy5lbmNvZGVOb2RlUHVibGljID0gZXhwb3J0cy5kZWNvZGVBY2NvdW50SUQgPSBleHBvcnRzLmVuY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZGVjb2RlU2VlZCA9IGV4cG9ydHMuZW5jb2RlU2VlZCA9IGV4cG9ydHMuY29kZWMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCB4cnBfY29kZWNfMSA9IHJlcXVpcmUoXCIuL3hycC1jb2RlY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvZGVjXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5jb2RlYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmVuY29kZVNlZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVTZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5kZWNvZGVTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQWNjb3VudElEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVBY2NvdW50SUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVBY2NvdW50SURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmRlY29kZUFjY291bnRJRDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZU5vZGVQdWJsaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmVuY29kZU5vZGVQdWJsaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVOb2RlUHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5kZWNvZGVOb2RlUHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQWNjb3VudFB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlQWNjb3VudFB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUFjY291bnRQdWJsaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmRlY29kZUFjY291bnRQdWJsaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkQ2xhc3NpY0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmlzVmFsaWRDbGFzc2ljQWRkcmVzczsgfSB9KTtcbmNvbnN0IFBSRUZJWF9CWVRFUyA9IHtcbiAgICAvLyA1LCA2OFxuICAgIG1haW46IEJ1ZmZlci5mcm9tKFsweDA1LCAweDQ0XSksXG4gICAgLy8gNCwgMTQ3XG4gICAgdGVzdDogQnVmZmVyLmZyb20oWzB4MDQsIDB4OTNdKSxcbn07XG5jb25zdCBNQVhfMzJfQklUX1VOU0lHTkVEX0lOVCA9IDQyOTQ5NjcyOTU7XG5mdW5jdGlvbiBjbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3MoY2xhc3NpY0FkZHJlc3MsIHRhZywgdGVzdCkge1xuICAgIGNvbnN0IGFjY291bnRJZCA9ICgwLCB4cnBfY29kZWNfMS5kZWNvZGVBY2NvdW50SUQpKGNsYXNzaWNBZGRyZXNzKTtcbiAgICByZXR1cm4gZW5jb2RlWEFkZHJlc3MoYWNjb3VudElkLCB0YWcsIHRlc3QpO1xufVxuZXhwb3J0cy5jbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3MgPSBjbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3M7XG5mdW5jdGlvbiBlbmNvZGVYQWRkcmVzcyhhY2NvdW50SWQsIHRhZywgdGVzdCkge1xuICAgIGlmIChhY2NvdW50SWQubGVuZ3RoICE9PSAyMCkge1xuICAgICAgICAvLyBSSVBFTUQxNjAgaXMgMTYwIGJpdHMgPSAyMCBieXRlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgSUQgbXVzdCBiZSAyMCBieXRlcycpO1xuICAgIH1cbiAgICBpZiAodGFnID4gTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZycpO1xuICAgIH1cbiAgICBjb25zdCB0aGVUYWcgPSB0YWcgfHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBQYXNzaW5nIG51bGwgaXMgYSBjb21tb24ganMgbWlzdGFrZVxuICAgIGNvbnN0IGZsYWcgPSB0YWcgPT09IGZhbHNlIHx8IHRhZyA9PSBudWxsID8gMCA6IDE7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAtLS1cbiAgICAgKiBuZWVkIHRvIHVzZSBiaXR3aXNlIG9wZXJhdGlvbnMgaGVyZSAqL1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIHRlc3QgPyBQUkVGSVhfQllURVMudGVzdCA6IFBSRUZJWF9CWVRFUy5tYWluLFxuICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgIEJ1ZmZlci5mcm9tKFtcbiAgICAgICAgICAgIC8vIDB4MDAgaWYgbm8gdGFnLCAweDAxIGlmIDMyLWJpdCB0YWdcbiAgICAgICAgICAgIGZsYWcsXG4gICAgICAgICAgICAvLyBmaXJzdCBieXRlXG4gICAgICAgICAgICB0aGVUYWcgJiAweGZmLFxuICAgICAgICAgICAgLy8gc2Vjb25kIGJ5dGVcbiAgICAgICAgICAgICh0aGVUYWcgPj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgLy8gdGhpcmQgYnl0ZVxuICAgICAgICAgICAgKHRoZVRhZyA+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgLy8gZm91cnRoIGJ5dGVcbiAgICAgICAgICAgICh0aGVUYWcgPj4gMjQpICYgMHhmZixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIC8vIGZvdXIgemVybyBieXRlcyAocmVzZXJ2ZWQgZm9yIDY0LWJpdCB0YWdzKVxuICAgICAgICAgICAgMCxcbiAgICAgICAgXSksXG4gICAgXSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG4gICAgcmV0dXJuIHhycF9jb2RlY18xLmNvZGVjLmVuY29kZUNoZWNrZWQoYnl0ZXMpO1xufVxuZXhwb3J0cy5lbmNvZGVYQWRkcmVzcyA9IGVuY29kZVhBZGRyZXNzO1xuZnVuY3Rpb24geEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uIC0tXG4gICAgICogVE9ETyAndGVzdCcgc2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlICdpc1Rlc3QnLCBkbyB0aGlzIGxhdGVyXG4gICAgICovXG4gICAgY29uc3QgeyBhY2NvdW50SWQsIHRhZywgdGVzdCB9ID0gZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpO1xuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4gICAgY29uc3QgY2xhc3NpY0FkZHJlc3MgPSAoMCwgeHJwX2NvZGVjXzEuZW5jb2RlQWNjb3VudElEKShhY2NvdW50SWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzaWNBZGRyZXNzLFxuICAgICAgICB0YWcsXG4gICAgICAgIHRlc3QsXG4gICAgfTtcbn1cbmV4cG9ydHMueEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzID0geEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzO1xuZnVuY3Rpb24gZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpIHtcbiAgICBjb25zdCBkZWNvZGVkID0geHJwX2NvZGVjXzEuY29kZWMuZGVjb2RlQ2hlY2tlZCh4QWRkcmVzcyk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uIC0tXG4gICAgICogVE9ETyAndGVzdCcgc2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlICdpc1Rlc3QnLCBkbyB0aGlzIGxhdGVyXG4gICAgICovXG4gICAgY29uc3QgdGVzdCA9IGlzQnVmZmVyRm9yVGVzdEFkZHJlc3MoZGVjb2RlZCk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbiAgICBjb25zdCBhY2NvdW50SWQgPSBkZWNvZGVkLnNsaWNlKDIsIDIyKTtcbiAgICBjb25zdCB0YWcgPSB0YWdGcm9tQnVmZmVyKGRlY29kZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgdGFnLFxuICAgICAgICB0ZXN0LFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZVhBZGRyZXNzID0gZGVjb2RlWEFkZHJlc3M7XG5mdW5jdGlvbiBpc0J1ZmZlckZvclRlc3RBZGRyZXNzKGJ1Zikge1xuICAgIGNvbnN0IGRlY29kZWRQcmVmaXggPSBidWYuc2xpY2UoMCwgMik7XG4gICAgaWYgKFBSRUZJWF9CWVRFUy5tYWluLmVxdWFscyhkZWNvZGVkUHJlZml4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChQUkVGSVhfQllURVMudGVzdC5lcXVhbHMoZGVjb2RlZFByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYLWFkZHJlc3M6IGJhZCBwcmVmaXgnKTtcbn1cbmZ1bmN0aW9uIHRhZ0Zyb21CdWZmZXIoYnVmKSB7XG4gICAgY29uc3QgZmxhZyA9IGJ1ZlsyMl07XG4gICAgaWYgKGZsYWcgPj0gMikge1xuICAgICAgICAvLyBObyBzdXBwb3J0IGZvciA2NC1iaXQgdGFncyBhdCB0aGlzIHRpbWVcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBYLWFkZHJlc3MnKTtcbiAgICB9XG4gICAgaWYgKGZsYWcgPT09IDEpIHtcbiAgICAgICAgLy8gTGl0dGxlLWVuZGlhbiB0byBiaWctZW5kaWFuXG4gICAgICAgIHJldHVybiBidWZbMjNdICsgYnVmWzI0XSAqIDB4MTAwICsgYnVmWzI1XSAqIDB4MTAwMDAgKyBidWZbMjZdICogMHgxMDAwMDAwO1xuICAgIH1cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoZmxhZywgMCwgJ2ZsYWcgbXVzdCBiZSB6ZXJvIHRvIGluZGljYXRlIG5vIHRhZycpO1xuICAgIGFzc2VydC5vayhCdWZmZXIuZnJvbSgnMDAwMDAwMDAwMDAwMDAwMCcsICdoZXgnKS5lcXVhbHMoYnVmLnNsaWNlKDIzLCAyMyArIDgpKSwgJ3JlbWFpbmluZyBieXRlcyBtdXN0IGJlIHplcm8nKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkWEFkZHJlc3MoeEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBkZWNvZGVYQWRkcmVzcyh4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNWYWxpZFhBZGRyZXNzID0gaXNWYWxpZFhBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-address-codec/dist/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatArgs = exports.seqEqual = void 0;\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nfunction seqEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.seqEqual = seqEqual;\n/**\n * Check whether a value is a sequence (e.g. Array of numbers).\n *\n * @param val - The value to check.\n */\nfunction isSequence(val) {\n    return typeof val !== 'number';\n}\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Buffer.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\nfunction concatArgs(...args) {\n    const ret = [];\n    args.forEach((arg) => {\n        if (isSequence(arg)) {\n            for (const j of arg) {\n                ret.push(j);\n            }\n        }\n        else {\n            ret.push(arg);\n        }\n    });\n    return ret;\n}\nexports.concatArgs = concatArgs;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL3hycGwtc3RhYmxlY29pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC91dGlscy5qcz9mYThmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25jYXRBcmdzID0gZXhwb3J0cy5zZXFFcXVhbCA9IHZvaWQgMDtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gc2VxdWVuY2VzIChlLmcuIEFycmF5cyBvZiBudW1iZXJzKSBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIGFycjEgLSBPbmUgb2YgdGhlIGFycmF5cyB0byBjb21wYXJlLlxuICogQHBhcmFtIGFycjIgLSBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqL1xuZnVuY3Rpb24gc2VxRXF1YWwoYXJyMSwgYXJyMikge1xuICAgIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuc2VxRXF1YWwgPSBzZXFFcXVhbDtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHZhbHVlIGlzIGEgc2VxdWVuY2UgKGUuZy4gQXJyYXkgb2YgbnVtYmVycykuXG4gKlxuICogQHBhcmFtIHZhbCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNTZXF1ZW5jZSh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ251bWJlcic7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlIGFsbCBgYXJndW1lbnRzYCBpbnRvIGEgc2luZ2xlIGFycmF5LiBFYWNoIGFyZ3VtZW50IGNhbiBiZSBlaXRoZXJcbiAqIGEgc2luZ2xlIGVsZW1lbnQgb3IgYSBzZXF1ZW5jZSwgd2hpY2ggaGFzIGEgYGxlbmd0aGAgcHJvcGVydHkgYW5kIHN1cHBvcnRzXG4gKiBlbGVtZW50IHJldHJpZXZhbCB2aWEgc2VxdWVuY2VbaXhdLlxuICpcbiAqID4gY29uY2F0QXJncygxLCBbMiwgM10sIEJ1ZmZlci5mcm9tKFs0LDVdKSwgbmV3IFVpbnQ4QXJyYXkoWzYsIDddKSk7XG4gKiBbMSwyLDMsNCw1LDYsN11cbiAqXG4gKiBAcGFyYW0gYXJncyAtIENvbmNhdGVuYXRlIG9mIHRoZXNlIGFyZ3MgaW50byBhIHNpbmdsZSBhcnJheS5cbiAqIEByZXR1cm5zIEFycmF5IG9mIGNvbmNhdGVuYXRlZCBhcmd1bWVudHNcbiAqL1xuZnVuY3Rpb24gY29uY2F0QXJncyguLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgYXJncy5mb3JFYWNoKChhcmcpID0+IHtcbiAgICAgICAgaWYgKGlzU2VxdWVuY2UoYXJnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBqIG9mIGFyZykge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLmNvbmNhdEFyZ3MgPSBjb25jYXRBcmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ripple-address-codec/dist/xrp-codec.js":
/*!*************************************************************!*\
  !*** ./node_modules/ripple-address-codec/dist/xrp-codec.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Codec class\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst baseCodec = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/base-x/src/index.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/ripple-address-codec/dist/utils.js\");\nclass Codec {\n    constructor(options) {\n        this._sha256 = options.sha256;\n        this._alphabet = options.alphabet;\n        this._codec = baseCodec(this._alphabet);\n    }\n    /**\n     * Encoder.\n     *\n     * @param bytes - Buffer of data to encode.\n     * @param opts - Options object including the version bytes and the expected length of the data to encode.\n     */\n    encode(bytes, opts) {\n        const versions = opts.versions;\n        return this._encodeVersioned(bytes, versions, opts.expectedLength);\n    }\n    /**\n     * Decoder.\n     *\n     * @param base58string - Base58Check-encoded string to decode.\n     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.\n     */\n    /* eslint-disable max-lines-per-function --\n     * TODO refactor */\n    decode(base58string, opts) {\n        var _a;\n        const versions = opts.versions;\n        const types = opts.versionTypes;\n        const withoutSum = this.decodeChecked(base58string);\n        if (versions.length > 1 && !opts.expectedLength) {\n            throw new Error('expectedLength is required because there are >= 2 possible versions');\n        }\n        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;\n        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;\n        const versionBytes = withoutSum.slice(0, -payloadLength);\n        const payload = withoutSum.slice(-payloadLength);\n        for (let i = 0; i < versions.length; i++) {\n            /* eslint-disable @typescript-eslint/consistent-type-assertions --\n             * TODO refactor */\n            const version = Array.isArray(versions[i])\n                ? versions[i]\n                : [versions[i]];\n            if ((0, utils_1.seqEqual)(versionBytes, version)) {\n                return {\n                    version,\n                    bytes: payload,\n                    type: types ? types[i] : null,\n                };\n            }\n            /* eslint-enable @typescript-eslint/consistent-type-assertions */\n        }\n        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');\n    }\n    encodeChecked(buffer) {\n        const check = this._sha256(this._sha256(buffer)).slice(0, 4);\n        return this._encodeRaw(Buffer.from((0, utils_1.concatArgs)(buffer, check)));\n    }\n    decodeChecked(base58string) {\n        const buffer = this._decodeRaw(base58string);\n        if (buffer.length < 5) {\n            throw new Error('invalid_input_size: decoded data must have length >= 5');\n        }\n        if (!this._verifyCheckSum(buffer)) {\n            throw new Error('checksum_invalid');\n        }\n        return buffer.slice(0, -4);\n    }\n    _encodeVersioned(bytes, versions, expectedLength) {\n        if (expectedLength && bytes.length !== expectedLength) {\n            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +\n                ' Ensure that the bytes are a Buffer.');\n        }\n        return this.encodeChecked(Buffer.from((0, utils_1.concatArgs)(versions, bytes)));\n    }\n    _encodeRaw(bytes) {\n        return this._codec.encode(bytes);\n    }\n    /* eslint-enable max-lines-per-function */\n    _decodeRaw(base58string) {\n        return this._codec.decode(base58string);\n    }\n    _verifyCheckSum(bytes) {\n        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);\n        const checksum = bytes.slice(-4);\n        return (0, utils_1.seqEqual)(computed, checksum);\n    }\n}\n/**\n * XRP codec\n */\n// base58 encodings: https://xrpl.org/base58-encodings.html\n// Account address (20 bytes)\nconst ACCOUNT_ID = 0;\n// Account public key (33 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23;\n// 33; Seed value (for secret keys) (16 bytes)\nconst FAMILY_SEED = 0x21;\n// 28; Validation public key (33 bytes)\nconst NODE_PUBLIC = 0x1c;\n// [1, 225, 75]\nconst ED25519_SEED = [0x01, 0xe1, 0x4b];\nconst codecOptions = {\n    sha256(bytes) {\n        return createHash('sha256').update(Buffer.from(bytes)).digest();\n    },\n    alphabet: 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz',\n};\nconst codecWithXrpAlphabet = new Codec(codecOptions);\nexports.codec = codecWithXrpAlphabet;\n// entropy is a Buffer of size 16\n// type is 'ed25519' or 'secp256k1'\nfunction encodeSeed(entropy, type) {\n    if (entropy.length !== 16) {\n        throw new Error('entropy must have length 16');\n    }\n    const opts = {\n        expectedLength: 16,\n        // for secp256k1, use `FAMILY_SEED`\n        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],\n    };\n    // prefixes entropy with version bytes\n    return codecWithXrpAlphabet.encode(entropy, opts);\n}\nexports.encodeSeed = encodeSeed;\nfunction decodeSeed(seed, opts = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16,\n}) {\n    return codecWithXrpAlphabet.decode(seed, opts);\n}\nexports.decodeSeed = decodeSeed;\nfunction encodeAccountID(bytes) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountID = encodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.encodeAddress = encodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeAccountID(accountId) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.decode(accountId, opts).bytes;\n}\nexports.decodeAccountID = decodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.decodeAddress = decodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeNodePublic(base58string) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeNodePublic = decodeNodePublic;\nfunction encodeNodePublic(bytes) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeNodePublic = encodeNodePublic;\nfunction encodeAccountPublic(bytes) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountPublic = encodeAccountPublic;\nfunction decodeAccountPublic(base58string) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeAccountPublic = decodeAccountPublic;\nfunction isValidClassicAddress(address) {\n    try {\n        decodeAccountID(address);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidClassicAddress = isValidClassicAddress;\n//# sourceMappingURL=xrp-codec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUM3UyxrQkFBa0IsbUJBQU8sQ0FBQyx3REFBUTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3hycGwtc3RhYmxlY29pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanM/MzlhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29kZWMgY2xhc3NcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZUFkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZW5jb2RlQWRkcmVzcyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZXhwb3J0cy5kZWNvZGVTZWVkID0gZXhwb3J0cy5lbmNvZGVTZWVkID0gZXhwb3J0cy5jb2RlYyA9IHZvaWQgMDtcbmNvbnN0IGJhc2VDb2RlYyA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG5jb25zdCBjcmVhdGVIYXNoID0gcmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY2xhc3MgQ29kZWMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc2hhMjU2ID0gb3B0aW9ucy5zaGEyNTY7XG4gICAgICAgIHRoaXMuX2FscGhhYmV0ID0gb3B0aW9ucy5hbHBoYWJldDtcbiAgICAgICAgdGhpcy5fY29kZWMgPSBiYXNlQ29kZWModGhpcy5fYWxwaGFiZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIC0gQnVmZmVyIG9mIGRhdGEgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGVzIGFuZCB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBkYXRhIHRvIGVuY29kZS5cbiAgICAgKi9cbiAgICBlbmNvZGUoYnl0ZXMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgb3B0cy5leHBlY3RlZExlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZTU4c3RyaW5nIC0gQmFzZTU4Q2hlY2stZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGUocykgYW5kIHRoZSBleHBlY3RlZCBsZW5ndGggb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb2RpbmcuXG4gICAgICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxpbmVzLXBlci1mdW5jdGlvbiAtLVxuICAgICAqIFRPRE8gcmVmYWN0b3IgKi9cbiAgICBkZWNvZGUoYmFzZTU4c3RyaW5nLCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICBjb25zdCB0eXBlcyA9IG9wdHMudmVyc2lvblR5cGVzO1xuICAgICAgICBjb25zdCB3aXRob3V0U3VtID0gdGhpcy5kZWNvZGVDaGVja2VkKGJhc2U1OHN0cmluZyk7XG4gICAgICAgIGlmICh2ZXJzaW9ucy5sZW5ndGggPiAxICYmICFvcHRzLmV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkTGVuZ3RoIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlcmUgYXJlID49IDIgcG9zc2libGUgdmVyc2lvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uTGVuZ3RoR3Vlc3MgPSB0eXBlb2YgdmVyc2lvbnNbMF0gPT09ICdudW1iZXInID8gMSA6IHZlcnNpb25zWzBdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IChfYSA9IG9wdHMuZXhwZWN0ZWRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpdGhvdXRTdW0ubGVuZ3RoIC0gdmVyc2lvbkxlbmd0aEd1ZXNzO1xuICAgICAgICBjb25zdCB2ZXJzaW9uQnl0ZXMgPSB3aXRob3V0U3VtLnNsaWNlKDAsIC1wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHdpdGhvdXRTdW0uc2xpY2UoLXBheWxvYWRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnMgLS1cbiAgICAgICAgICAgICAqIFRPRE8gcmVmYWN0b3IgKi9cbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBBcnJheS5pc0FycmF5KHZlcnNpb25zW2ldKVxuICAgICAgICAgICAgICAgID8gdmVyc2lvbnNbaV1cbiAgICAgICAgICAgICAgICA6IFt2ZXJzaW9uc1tpXV07XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuc2VxRXF1YWwpKHZlcnNpb25CeXRlcywgdmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBieXRlczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZXMgPyB0eXBlc1tpXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zICovXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJzaW9uX2ludmFsaWQ6IHZlcnNpb24gYnl0ZXMgZG8gbm90IG1hdGNoIGFueSBvZiB0aGUgcHJvdmlkZWQgdmVyc2lvbihzKScpO1xuICAgIH1cbiAgICBlbmNvZGVDaGVja2VkKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBjaGVjayA9IHRoaXMuX3NoYTI1Nih0aGlzLl9zaGEyNTYoYnVmZmVyKSkuc2xpY2UoMCwgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVSYXcoQnVmZmVyLmZyb20oKDAsIHV0aWxzXzEuY29uY2F0QXJncykoYnVmZmVyLCBjaGVjaykpKTtcbiAgICB9XG4gICAgZGVjb2RlQ2hlY2tlZChiYXNlNThzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5fZGVjb2RlUmF3KGJhc2U1OHN0cmluZyk7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkX2lucHV0X3NpemU6IGRlY29kZWQgZGF0YSBtdXN0IGhhdmUgbGVuZ3RoID49IDUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNoZWNrU3VtKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW1faW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoMCwgLTQpO1xuICAgIH1cbiAgICBfZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkTGVuZ3RoICYmIGJ5dGVzLmxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZF9wYXlsb2FkX2xlbmd0aDogYnl0ZXMubGVuZ3RoIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkTGVuZ3RoLicgK1xuICAgICAgICAgICAgICAgICcgRW5zdXJlIHRoYXQgdGhlIGJ5dGVzIGFyZSBhIEJ1ZmZlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVDaGVja2VkKEJ1ZmZlci5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKHZlcnNpb25zLCBieXRlcykpKTtcbiAgICB9XG4gICAgX2VuY29kZVJhdyhieXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29kZWMuZW5jb2RlKGJ5dGVzKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uICovXG4gICAgX2RlY29kZVJhdyhiYXNlNThzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVjLmRlY29kZShiYXNlNThzdHJpbmcpO1xuICAgIH1cbiAgICBfdmVyaWZ5Q2hlY2tTdW0oYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLl9zaGEyNTYodGhpcy5fc2hhMjU2KGJ5dGVzLnNsaWNlKDAsIC00KSkpLnNsaWNlKDAsIDQpO1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGJ5dGVzLnNsaWNlKC00KTtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnNlcUVxdWFsKShjb21wdXRlZCwgY2hlY2tzdW0pO1xuICAgIH1cbn1cbi8qKlxuICogWFJQIGNvZGVjXG4gKi9cbi8vIGJhc2U1OCBlbmNvZGluZ3M6IGh0dHBzOi8veHJwbC5vcmcvYmFzZTU4LWVuY29kaW5ncy5odG1sXG4vLyBBY2NvdW50IGFkZHJlc3MgKDIwIGJ5dGVzKVxuY29uc3QgQUNDT1VOVF9JRCA9IDA7XG4vLyBBY2NvdW50IHB1YmxpYyBrZXkgKDMzIGJ5dGVzKVxuY29uc3QgQUNDT1VOVF9QVUJMSUNfS0VZID0gMHgyMztcbi8vIDMzOyBTZWVkIHZhbHVlIChmb3Igc2VjcmV0IGtleXMpICgxNiBieXRlcylcbmNvbnN0IEZBTUlMWV9TRUVEID0gMHgyMTtcbi8vIDI4OyBWYWxpZGF0aW9uIHB1YmxpYyBrZXkgKDMzIGJ5dGVzKVxuY29uc3QgTk9ERV9QVUJMSUMgPSAweDFjO1xuLy8gWzEsIDIyNSwgNzVdXG5jb25zdCBFRDI1NTE5X1NFRUQgPSBbMHgwMSwgMHhlMSwgMHg0Yl07XG5jb25zdCBjb2RlY09wdGlvbnMgPSB7XG4gICAgc2hhMjU2KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoQnVmZmVyLmZyb20oYnl0ZXMpKS5kaWdlc3QoKTtcbiAgICB9LFxuICAgIGFscGhhYmV0OiAncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicsXG59O1xuY29uc3QgY29kZWNXaXRoWHJwQWxwaGFiZXQgPSBuZXcgQ29kZWMoY29kZWNPcHRpb25zKTtcbmV4cG9ydHMuY29kZWMgPSBjb2RlY1dpdGhYcnBBbHBoYWJldDtcbi8vIGVudHJvcHkgaXMgYSBCdWZmZXIgb2Ygc2l6ZSAxNlxuLy8gdHlwZSBpcyAnZWQyNTUxOScgb3IgJ3NlY3AyNTZrMSdcbmZ1bmN0aW9uIGVuY29kZVNlZWQoZW50cm9weSwgdHlwZSkge1xuICAgIGlmIChlbnRyb3B5Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyb3B5IG11c3QgaGF2ZSBsZW5ndGggMTYnKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IDE2LFxuICAgICAgICAvLyBmb3Igc2VjcDI1NmsxLCB1c2UgYEZBTUlMWV9TRUVEYFxuICAgICAgICB2ZXJzaW9uczogdHlwZSA9PT0gJ2VkMjU1MTknID8gRUQyNTUxOV9TRUVEIDogW0ZBTUlMWV9TRUVEXSxcbiAgICB9O1xuICAgIC8vIHByZWZpeGVzIGVudHJvcHkgd2l0aCB2ZXJzaW9uIGJ5dGVzXG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShlbnRyb3B5LCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlU2VlZCA9IGVuY29kZVNlZWQ7XG5mdW5jdGlvbiBkZWNvZGVTZWVkKHNlZWQsIG9wdHMgPSB7XG4gICAgdmVyc2lvblR5cGVzOiBbJ2VkMjU1MTknLCAnc2VjcDI1NmsxJ10sXG4gICAgdmVyc2lvbnM6IFtFRDI1NTE5X1NFRUQsIEZBTUlMWV9TRUVEXSxcbiAgICBleHBlY3RlZExlbmd0aDogMTYsXG59KSB7XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShzZWVkLCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGRlY29kZVNlZWQ7XG5mdW5jdGlvbiBlbmNvZGVBY2NvdW50SUQoYnl0ZXMpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfSURdLCBleHBlY3RlZExlbmd0aDogMjAgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZW5jb2RlQWNjb3VudElEO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzIC0tLVxuICogdW5jbGVhciB3aHkgdGhpcyBpcyBhbGlhc2VkIGJ1dCB3ZSBzaG91bGQga2VlcCBpdCBpbiBjYXNlIHNvbWVvbmUgZWxzZSBpc1xuICogaW1wb3J0aW5nIGl0IHdpdGggdGhlIGFsaWFzZWQgbmFtZSAqL1xuZXhwb3J0cy5lbmNvZGVBZGRyZXNzID0gZW5jb2RlQWNjb3VudElEO1xuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXMgKi9cbmZ1bmN0aW9uIGRlY29kZUFjY291bnRJRChhY2NvdW50SWQpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfSURdLCBleHBlY3RlZExlbmd0aDogMjAgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZGVjb2RlKGFjY291bnRJZCwgb3B0cykuYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGRlY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAtLS1cbiAqIHVuY2xlYXIgd2h5IHRoaXMgaXMgYWxpYXNlZCBidXQgd2Ugc2hvdWxkIGtlZXAgaXQgaW4gY2FzZSBzb21lb25lIGVsc2UgaXNcbiAqIGltcG9ydGluZyBpdCB3aXRoIHRoZSBhbGlhc2VkIG5hbWUgKi9cbmV4cG9ydHMuZGVjb2RlQWRkcmVzcyA9IGRlY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzICovXG5mdW5jdGlvbiBkZWNvZGVOb2RlUHVibGljKGJhc2U1OHN0cmluZykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbTk9ERV9QVUJMSUNdLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZGVjb2RlKGJhc2U1OHN0cmluZywgb3B0cykuYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBkZWNvZGVOb2RlUHVibGljO1xuZnVuY3Rpb24gZW5jb2RlTm9kZVB1YmxpYyhieXRlcykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbTk9ERV9QVUJMSUNdLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlTm9kZVB1YmxpYyA9IGVuY29kZU5vZGVQdWJsaWM7XG5mdW5jdGlvbiBlbmNvZGVBY2NvdW50UHVibGljKGJ5dGVzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX1BVQkxJQ19LRVldLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlQWNjb3VudFB1YmxpYyA9IGVuY29kZUFjY291bnRQdWJsaWM7XG5mdW5jdGlvbiBkZWNvZGVBY2NvdW50UHVibGljKGJhc2U1OHN0cmluZykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbQUNDT1VOVF9QVUJMSUNfS0VZXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShiYXNlNThzdHJpbmcsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVBY2NvdW50UHVibGljID0gZGVjb2RlQWNjb3VudFB1YmxpYztcbmZ1bmN0aW9uIGlzVmFsaWRDbGFzc2ljQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlQWNjb3VudElEKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyA9IGlzVmFsaWRDbGFzc2ljQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhycC1jb2RlYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ripple-address-codec/dist/xrp-codec.js\n");

/***/ })

};
;