"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useRealTimeData.ts":
/*!**************************************!*\
  !*** ./src/hooks/useRealTimeData.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRealTimeData: function() { return /* binding */ useRealTimeData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/xrpl-service */ \"(app-pages-browser)/./src/lib/xrpl-service.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ useRealTimeData auto */ \n\nfunction useRealTimeData() {\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        totalSupply: \"0\",\n        circulation: \"0\",\n        activeWallets: \"0\",\n        transactions24h: \"0\"\n    });\n    const [transactions, setTransactions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [walletBalances, setWalletBalances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Configuration from environment\n    const ADMIN_ADDRESS = process.env.NEXT_PUBLIC_ADMIN_ADDRESS || \"rph2KgyZXNn3fhFrDAmwmvbS5h8dQjd2ZM\";\n    const TREASURY_ADDRESS = process.env.NEXT_PUBLIC_TREASURY_ADDRESS || \"rAbc123XYZ456DEF789GHI012JKL345MNO\";\n    const CURRENCY_CODE = process.env.NEXT_PUBLIC_CURRENCY_CODE || \"TZS\";\n    // Fetch wallet balances\n    const fetchWalletBalances = async ()=>{\n        try {\n            const adminXRP = await _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.getXRPBalance(ADMIN_ADDRESS);\n            const treasuryTZS = await _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.getTokenBalance(TREASURY_ADDRESS, CURRENCY_CODE, ADMIN_ADDRESS);\n            setWalletBalances({\n                [ADMIN_ADDRESS]: \"\".concat(adminXRP.toFixed(2), \" XRP\"),\n                [TREASURY_ADDRESS]: \"\".concat(treasuryTZS.toFixed(0), \" TZS\")\n            });\n        } catch (error) {\n            console.error(\"Error fetching wallet balances:\", error);\n        }\n    };\n    // Fetch recent transactions\n    const fetchTransactions = async ()=>{\n        try {\n            const adminTxs = await _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.getAccountTransactions(ADMIN_ADDRESS, 10);\n            const treasuryTxs = await _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.getAccountTransactions(TREASURY_ADDRESS, 10);\n            const allTxs = [\n                ...adminTxs.result.transactions,\n                ...treasuryTxs.result.transactions\n            ];\n            const formattedTxs = allTxs.map((tx)=>{\n                const transaction = tx.tx || tx;\n                const meta = tx.meta || {};\n                return {\n                    hash: transaction.hash || transaction.Hash,\n                    type: getTransactionType(transaction),\n                    amount: getTransactionAmount(transaction, meta),\n                    from: transaction.Account,\n                    to: transaction.Destination || \"N/A\",\n                    status: meta.TransactionResult === \"tesSUCCESS\" ? \"validated\" : \"failed\",\n                    timestamp: formatTimestamp(transaction.date)\n                };\n            }).slice(0, 10);\n            setTransactions(formattedTxs);\n            // Update 24h transaction count\n            setStats((prev)=>({\n                    ...prev,\n                    transactions24h: formattedTxs.length.toString()\n                }));\n        } catch (error) {\n            console.error(\"Error fetching transactions:\", error);\n        }\n    };\n    // Calculate token statistics\n    const calculateStats = async ()=>{\n        try {\n            // This would typically come from your backend API\n            // For now, we'll estimate based on available data\n            const treasuryBalance = await _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.getTokenBalance(TREASURY_ADDRESS, CURRENCY_CODE, ADMIN_ADDRESS);\n            setStats((prev)=>({\n                    ...prev,\n                    totalSupply: \"1250000\",\n                    circulation: Math.max(0, 1250000 - treasuryBalance).toString(),\n                    activeWallets: \"1247\" // This should come from your backend\n                }));\n        } catch (error) {\n            console.error(\"Error calculating stats:\", error);\n        }\n    };\n    // Set up real-time transaction monitoring\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const setupRealTimeMonitoring = async ()=>{\n            try {\n                // Subscribe to real-time transactions\n                _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.subscribeToTransactions([\n                    ADMIN_ADDRESS,\n                    TREASURY_ADDRESS\n                ], (transaction)=>{\n                    const newTx = {\n                        hash: transaction.transaction.hash,\n                        type: getTransactionType(transaction.transaction),\n                        amount: getTransactionAmount(transaction.transaction, transaction.meta),\n                        from: transaction.transaction.Account,\n                        to: transaction.transaction.Destination || \"N/A\",\n                        status: transaction.meta.TransactionResult === \"tesSUCCESS\" ? \"validated\" : \"failed\",\n                        timestamp: \"Just now\"\n                    };\n                    setTransactions((prev)=>[\n                            newTx,\n                            ...prev.slice(0, 9)\n                        ]);\n                });\n            } catch (error) {\n                console.error(\"Error setting up real-time monitoring:\", error);\n            }\n        };\n        setupRealTimeMonitoring();\n        return ()=>{\n            _lib_xrpl_service__WEBPACK_IMPORTED_MODULE_1__.xrplService.unsubscribeFromTransactions();\n        };\n    }, [\n        ADMIN_ADDRESS,\n        TREASURY_ADDRESS\n    ]);\n    // Initial data fetch\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fetchInitialData = async ()=>{\n            setIsLoading(true);\n            await Promise.all([\n                fetchWalletBalances(),\n                fetchTransactions(),\n                calculateStats()\n            ]);\n            setIsLoading(false);\n        };\n        fetchInitialData();\n        // Set up periodic refresh\n        const interval = setInterval(()=>{\n            fetchWalletBalances();\n            fetchTransactions();\n            calculateStats();\n        }, 30000) // Refresh every 30 seconds\n        ;\n        return ()=>clearInterval(interval);\n    }, []);\n    return {\n        stats,\n        transactions,\n        walletBalances,\n        isLoading,\n        refreshData: ()=>{\n            fetchWalletBalances();\n            fetchTransactions();\n            calculateStats();\n        }\n    };\n}\n// Helper functions\nfunction getTransactionType(transaction) {\n    if (transaction.TransactionType === \"TrustSet\") return \"mint\";\n    if (transaction.TransactionType === \"Payment\") return \"transfer\";\n    return \"transfer\";\n}\nfunction getTransactionAmount(transaction, meta) {\n    if (transaction.Amount) {\n        if (typeof transaction.Amount === \"string\") {\n            return \"\".concat((parseInt(transaction.Amount) / 1000000).toFixed(2), \" XRP\");\n        } else {\n            return \"\".concat(transaction.Amount.value, \" \").concat(transaction.Amount.currency);\n        }\n    }\n    return \"0\";\n}\nfunction formatTimestamp(rippleTime) {\n    if (!rippleTime) return \"Unknown\";\n    // Convert Ripple timestamp to Unix timestamp\n    const unixTime = (rippleTime + 946684800) * 1000;\n    const date = new Date(unixTime);\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffMins = Math.floor(diffMs / 60000);\n    if (diffMins < 1) return \"Just now\";\n    if (diffMins < 60) return \"\".concat(diffMins, \" min ago\");\n    if (diffMins < 1440) return \"\".concat(Math.floor(diffMins / 60), \" hr ago\");\n    return date.toLocaleDateString();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VSZWFsVGltZURhdGEudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cUVBRTJDO0FBQ0s7QUFtQnpDLFNBQVNHO0lBQ2QsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdMLCtDQUFRQSxDQUFhO1FBQzdDTSxhQUFhO1FBQ2JDLGFBQWE7UUFDYkMsZUFBZTtRQUNmQyxpQkFBaUI7SUFDbkI7SUFFQSxNQUFNLENBQUNDLGNBQWNDLGdCQUFnQixHQUFHWCwrQ0FBUUEsQ0FBZ0IsRUFBRTtJQUNsRSxNQUFNLENBQUNZLGdCQUFnQkMsa0JBQWtCLEdBQUdiLCtDQUFRQSxDQUF5QixDQUFDO0lBQzlFLE1BQU0sQ0FBQ2MsV0FBV0MsYUFBYSxHQUFHZiwrQ0FBUUEsQ0FBQztJQUUzQyxpQ0FBaUM7SUFDakMsTUFBTWdCLGdCQUFnQkMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx5QkFBeUIsSUFBSTtJQUMvRCxNQUFNQyxtQkFBbUJILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0csNEJBQTRCLElBQUk7SUFDckUsTUFBTUMsZ0JBQWdCTCxPQUFPQSxDQUFDQyxHQUFHLENBQUNLLHlCQUF5QixJQUFJO0lBRS9ELHdCQUF3QjtJQUN4QixNQUFNQyxzQkFBc0I7UUFDMUIsSUFBSTtZQUNGLE1BQU1DLFdBQVcsTUFBTXZCLDBEQUFXQSxDQUFDd0IsYUFBYSxDQUFDVjtZQUNqRCxNQUFNVyxjQUFjLE1BQU16QiwwREFBV0EsQ0FBQzBCLGVBQWUsQ0FBQ1Isa0JBQWtCRSxlQUFlTjtZQUV2Rkgsa0JBQWtCO2dCQUNoQixDQUFDRyxjQUFjLEVBQUUsR0FBdUIsT0FBcEJTLFNBQVNJLE9BQU8sQ0FBQyxJQUFHO2dCQUN4QyxDQUFDVCxpQkFBaUIsRUFBRSxHQUEwQixPQUF2Qk8sWUFBWUUsT0FBTyxDQUFDLElBQUc7WUFDaEQ7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDbkQ7SUFD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SUFDNUMsTUFBTXpCLE9BQU8sSUFBSTJCLEtBQUtEO0lBQ3RCLE1BQU1FLE1BQU0sSUFBSUQ7SUFDaEIsTUFBTUUsU0FBU0QsSUFBSUUsT0FBTyxLQUFLOUIsS0FBSzhCLE9BQU87SUFDM0MsTUFBTUMsV0FBV3hCLEtBQUt5QixLQUFLLENBQUNILFNBQVM7SUFFckMsSUFBSUUsV0FBVyxHQUFHLE9BQU87SUFDekIsSUFBSUEsV0FBVyxJQUFJLE9BQU8sR0FBWSxPQUFUQSxVQUFTO0lBQ3RDLElBQUlBLFdBQVcsTUFBTSxPQUFPLEdBQTZCLE9BQTFCeEIsS0FBS3lCLEtBQUssQ0FBQ0QsV0FBVyxLQUFJO0lBQ3pELE9BQU8vQixLQUFLaUMsa0JBQWtCO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VSZWFsVGltZURhdGEudHM/MmNiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgeHJwbFNlcnZpY2UgfSBmcm9tICdAL2xpYi94cnBsLXNlcnZpY2UnXG5cbmludGVyZmFjZSBUb2tlblN0YXRzIHtcbiAgdG90YWxTdXBwbHk6IHN0cmluZ1xuICBjaXJjdWxhdGlvbjogc3RyaW5nXG4gIGFjdGl2ZVdhbGxldHM6IHN0cmluZ1xuICB0cmFuc2FjdGlvbnMyNGg6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb24ge1xuICBoYXNoOiBzdHJpbmdcbiAgdHlwZTogJ21pbnQnIHwgJ2J1cm4nIHwgJ3RyYW5zZmVyJ1xuICBhbW91bnQ6IHN0cmluZ1xuICBmcm9tOiBzdHJpbmdcbiAgdG86IHN0cmluZ1xuICBzdGF0dXM6ICdwZW5kaW5nJyB8ICd2YWxpZGF0ZWQnIHwgJ2ZhaWxlZCdcbiAgdGltZXN0YW1wOiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlYWxUaW1lRGF0YSgpIHtcbiAgY29uc3QgW3N0YXRzLCBzZXRTdGF0c10gPSB1c2VTdGF0ZTxUb2tlblN0YXRzPih7XG4gICAgdG90YWxTdXBwbHk6ICcwJyxcbiAgICBjaXJjdWxhdGlvbjogJzAnLFxuICAgIGFjdGl2ZVdhbGxldHM6ICcwJyxcbiAgICB0cmFuc2FjdGlvbnMyNGg6ICcwJ1xuICB9KVxuICBcbiAgY29uc3QgW3RyYW5zYWN0aW9ucywgc2V0VHJhbnNhY3Rpb25zXSA9IHVzZVN0YXRlPFRyYW5zYWN0aW9uW10+KFtdKVxuICBjb25zdCBbd2FsbGV0QmFsYW5jZXMsIHNldFdhbGxldEJhbGFuY2VzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KHt9KVxuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcblxuICAvLyBDb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnRcbiAgY29uc3QgQURNSU5fQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FETUlOX0FERFJFU1MgfHwgJ3JwaDJLZ3laWE5uM2ZoRnJEQW13bXZiUzVoOGRRamQyWk0nXG4gIGNvbnN0IFRSRUFTVVJZX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19UUkVBU1VSWV9BRERSRVNTIHx8ICdyQWJjMTIzWFlaNDU2REVGNzg5R0hJMDEySktMMzQ1TU5PJ1xuICBjb25zdCBDVVJSRU5DWV9DT0RFID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ1VSUkVOQ1lfQ09ERSB8fCAnVFpTJ1xuXG4gIC8vIEZldGNoIHdhbGxldCBiYWxhbmNlc1xuICBjb25zdCBmZXRjaFdhbGxldEJhbGFuY2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZG1pblhSUCA9IGF3YWl0IHhycGxTZXJ2aWNlLmdldFhSUEJhbGFuY2UoQURNSU5fQUREUkVTUylcbiAgICAgIGNvbnN0IHRyZWFzdXJ5VFpTID0gYXdhaXQgeHJwbFNlcnZpY2UuZ2V0VG9rZW5CYWxhbmNlKFRSRUFTVVJZX0FERFJFU1MsIENVUlJFTkNZX0NPREUsIEFETUlOX0FERFJFU1MpXG4gICAgICBcbiAgICAgIHNldFdhbGxldEJhbGFuY2VzKHtcbiAgICAgICAgW0FETUlOX0FERFJFU1NdOiBgJHthZG1pblhSUC50b0ZpeGVkKDIpfSBYUlBgLFxuICAgICAgICBbVFJFQVNVUllfQUREUkVTU106IGAke3RyZWFzdXJ5VFpTLnRvRml4ZWQoMCl9IFRaU2BcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHdhbGxldCBiYWxhbmNlczonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCByZWNlbnQgdHJhbnNhY3Rpb25zXG4gIGNvbnN0IGZldGNoVHJhbnNhY3Rpb25zID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZG1pblR4cyA9IGF3YWl0IHhycGxTZXJ2aWNlLmdldEFjY291bnRUcmFuc2FjdGlvbnMoQURNSU5fQUREUkVTUywgMTApXG4gICAgICBjb25zdCB0cmVhc3VyeVR4cyA9IGF3YWl0IHhycGxTZXJ2aWNlLmdldEFjY291bnRUcmFuc2FjdGlvbnMoVFJFQVNVUllfQUREUkVTUywgMTApXG4gICAgICBcbiAgICAgIGNvbnN0IGFsbFR4cyA9IFsuLi5hZG1pblR4cy5yZXN1bHQudHJhbnNhY3Rpb25zLCAuLi50cmVhc3VyeVR4cy5yZXN1bHQudHJhbnNhY3Rpb25zXVxuICAgICAgXG4gICAgICBjb25zdCBmb3JtYXR0ZWRUeHM6IFRyYW5zYWN0aW9uW10gPSBhbGxUeHMubWFwKCh0eDogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHgudHggfHwgdHhcbiAgICAgICAgY29uc3QgbWV0YSA9IHR4Lm1ldGEgfHwge31cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzaDogdHJhbnNhY3Rpb24uaGFzaCB8fCB0cmFuc2FjdGlvbi5IYXNoLFxuICAgICAgICAgIHR5cGU6IGdldFRyYW5zYWN0aW9uVHlwZSh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgYW1vdW50OiBnZXRUcmFuc2FjdGlvbkFtb3VudCh0cmFuc2FjdGlvbiwgbWV0YSksXG4gICAgICAgICAgZnJvbTogdHJhbnNhY3Rpb24uQWNjb3VudCxcbiAgICAgICAgICB0bzogdHJhbnNhY3Rpb24uRGVzdGluYXRpb24gfHwgJ04vQScsXG4gICAgICAgICAgc3RhdHVzOiAobWV0YS5UcmFuc2FjdGlvblJlc3VsdCA9PT0gJ3Rlc1NVQ0NFU1MnID8gJ3ZhbGlkYXRlZCcgOiAnZmFpbGVkJykgYXMgJ3BlbmRpbmcnIHwgJ3ZhbGlkYXRlZCcgfCAnZmFpbGVkJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IGZvcm1hdFRpbWVzdGFtcCh0cmFuc2FjdGlvbi5kYXRlKVxuICAgICAgICB9XG4gICAgICB9KS5zbGljZSgwLCAxMClcbiAgICAgIFxuICAgICAgc2V0VHJhbnNhY3Rpb25zKGZvcm1hdHRlZFR4cylcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIDI0aCB0cmFuc2FjdGlvbiBjb3VudFxuICAgICAgc2V0U3RhdHMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB0cmFuc2FjdGlvbnMyNGg6IGZvcm1hdHRlZFR4cy5sZW5ndGgudG9TdHJpbmcoKVxuICAgICAgfSkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRyYW5zYWN0aW9uczonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdG9rZW4gc3RhdGlzdGljc1xuICBjb25zdCBjYWxjdWxhdGVTdGF0cyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgY29tZSBmcm9tIHlvdXIgYmFja2VuZCBBUElcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGVzdGltYXRlIGJhc2VkIG9uIGF2YWlsYWJsZSBkYXRhXG4gICAgICBjb25zdCB0cmVhc3VyeUJhbGFuY2UgPSBhd2FpdCB4cnBsU2VydmljZS5nZXRUb2tlbkJhbGFuY2UoVFJFQVNVUllfQUREUkVTUywgQ1VSUkVOQ1lfQ09ERSwgQURNSU5fQUREUkVTUylcbiAgICAgIFxuICAgICAgc2V0U3RhdHMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB0b3RhbFN1cHBseTogJzEyNTAwMDAnLCAvLyBUaGlzIHNob3VsZCBjb21lIGZyb20geW91ciBiYWNrZW5kXG4gICAgICAgIGNpcmN1bGF0aW9uOiBNYXRoLm1heCgwLCAxMjUwMDAwIC0gdHJlYXN1cnlCYWxhbmNlKS50b1N0cmluZygpLFxuICAgICAgICBhY3RpdmVXYWxsZXRzOiAnMTI0NycgLy8gVGhpcyBzaG91bGQgY29tZSBmcm9tIHlvdXIgYmFja2VuZFxuICAgICAgfSkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGN1bGF0aW5nIHN0YXRzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB1cCByZWFsLXRpbWUgdHJhbnNhY3Rpb24gbW9uaXRvcmluZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNldHVwUmVhbFRpbWVNb25pdG9yaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHJlYWwtdGltZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgeHJwbFNlcnZpY2Uuc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMoW0FETUlOX0FERFJFU1MsIFRSRUFTVVJZX0FERFJFU1NdLCAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdUeDogVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICBoYXNoOiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbi5oYXNoLFxuICAgICAgICAgICAgdHlwZTogZ2V0VHJhbnNhY3Rpb25UeXBlKHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIGFtb3VudDogZ2V0VHJhbnNhY3Rpb25BbW91bnQodHJhbnNhY3Rpb24udHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLm1ldGEpLFxuICAgICAgICAgICAgZnJvbTogdHJhbnNhY3Rpb24udHJhbnNhY3Rpb24uQWNjb3VudCxcbiAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbi5EZXN0aW5hdGlvbiB8fCAnTi9BJyxcbiAgICAgICAgICAgIHN0YXR1czogdHJhbnNhY3Rpb24ubWV0YS5UcmFuc2FjdGlvblJlc3VsdCA9PT0gJ3Rlc1NVQ0NFU1MnID8gJ3ZhbGlkYXRlZCcgOiAnZmFpbGVkJyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogJ0p1c3Qgbm93J1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBzZXRUcmFuc2FjdGlvbnMocHJldiA9PiBbbmV3VHgsIC4uLnByZXYuc2xpY2UoMCwgOSldKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2V0dGluZyB1cCByZWFsLXRpbWUgbW9uaXRvcmluZzonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFJlYWxUaW1lTW9uaXRvcmluZygpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgeHJwbFNlcnZpY2UudW5zdWJzY3JpYmVGcm9tVHJhbnNhY3Rpb25zKClcbiAgICB9XG4gIH0sIFtBRE1JTl9BRERSRVNTLCBUUkVBU1VSWV9BRERSRVNTXSlcblxuICAvLyBJbml0aWFsIGRhdGEgZmV0Y2hcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaEluaXRpYWxEYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGZldGNoV2FsbGV0QmFsYW5jZXMoKSxcbiAgICAgICAgZmV0Y2hUcmFuc2FjdGlvbnMoKSxcbiAgICAgICAgY2FsY3VsYXRlU3RhdHMoKVxuICAgICAgXSlcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICB9XG5cbiAgICBmZXRjaEluaXRpYWxEYXRhKClcblxuICAgIC8vIFNldCB1cCBwZXJpb2RpYyByZWZyZXNoXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBmZXRjaFdhbGxldEJhbGFuY2VzKClcbiAgICAgIGZldGNoVHJhbnNhY3Rpb25zKClcbiAgICAgIGNhbGN1bGF0ZVN0YXRzKClcbiAgICB9LCAzMDAwMCkgLy8gUmVmcmVzaCBldmVyeSAzMCBzZWNvbmRzXG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgfSwgW10pXG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0cyxcbiAgICB0cmFuc2FjdGlvbnMsXG4gICAgd2FsbGV0QmFsYW5jZXMsXG4gICAgaXNMb2FkaW5nLFxuICAgIHJlZnJlc2hEYXRhOiAoKSA9PiB7XG4gICAgICBmZXRjaFdhbGxldEJhbGFuY2VzKClcbiAgICAgIGZldGNoVHJhbnNhY3Rpb25zKClcbiAgICAgIGNhbGN1bGF0ZVN0YXRzKClcbiAgICB9XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25UeXBlKHRyYW5zYWN0aW9uOiBhbnkpOiAnbWludCcgfCAnYnVybicgfCAndHJhbnNmZXInIHtcbiAgaWYgKHRyYW5zYWN0aW9uLlRyYW5zYWN0aW9uVHlwZSA9PT0gJ1RydXN0U2V0JykgcmV0dXJuICdtaW50J1xuICBpZiAodHJhbnNhY3Rpb24uVHJhbnNhY3Rpb25UeXBlID09PSAnUGF5bWVudCcpIHJldHVybiAndHJhbnNmZXInXG4gIHJldHVybiAndHJhbnNmZXInXG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uQW1vdW50KHRyYW5zYWN0aW9uOiBhbnksIG1ldGE6IGFueSk6IHN0cmluZyB7XG4gIGlmICh0cmFuc2FjdGlvbi5BbW91bnQpIHtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLkFtb3VudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBgJHsocGFyc2VJbnQodHJhbnNhY3Rpb24uQW1vdW50KSAvIDEwMDAwMDApLnRvRml4ZWQoMil9IFhSUGBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke3RyYW5zYWN0aW9uLkFtb3VudC52YWx1ZX0gJHt0cmFuc2FjdGlvbi5BbW91bnQuY3VycmVuY3l9YFxuICAgIH1cbiAgfVxuICByZXR1cm4gJzAnXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWVzdGFtcChyaXBwbGVUaW1lPzogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKCFyaXBwbGVUaW1lKSByZXR1cm4gJ1Vua25vd24nXG4gIFxuICAvLyBDb252ZXJ0IFJpcHBsZSB0aW1lc3RhbXAgdG8gVW5peCB0aW1lc3RhbXBcbiAgY29uc3QgdW5peFRpbWUgPSAocmlwcGxlVGltZSArIDk0NjY4NDgwMCkgKiAxMDAwXG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh1bml4VGltZSlcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICBjb25zdCBkaWZmTXMgPSBub3cuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKClcbiAgY29uc3QgZGlmZk1pbnMgPSBNYXRoLmZsb29yKGRpZmZNcyAvIDYwMDAwKVxuICBcbiAgaWYgKGRpZmZNaW5zIDwgMSkgcmV0dXJuICdKdXN0IG5vdydcbiAgaWYgKGRpZmZNaW5zIDwgNjApIHJldHVybiBgJHtkaWZmTWluc30gbWluIGFnb2BcbiAgaWYgKGRpZmZNaW5zIDwgMTQ0MCkgcmV0dXJuIGAke01hdGguZmxvb3IoZGlmZk1pbnMgLyA2MCl9IGhyIGFnb2BcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKClcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInhycGxTZXJ2aWNlIiwidXNlUmVhbFRpbWVEYXRhIiwic3RhdHMiLCJzZXRTdGF0cyIsInRvdGFsU3VwcGx5IiwiY2lyY3VsYXRpb24iLCJhY3RpdmVXYWxsZXRzIiwidHJhbnNhY3Rpb25zMjRoIiwidHJhbnNhY3Rpb25zIiwic2V0VHJhbnNhY3Rpb25zIiwid2FsbGV0QmFsYW5jZXMiLCJzZXRXYWxsZXRCYWxhbmNlcyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsIkFETUlOX0FERFJFU1MiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQURNSU5fQUREUkVTUyIsIlRSRUFTVVJZX0FERFJFU1MiLCJORVhUX1BVQkxJQ19UUkVBU1VSWV9BRERSRVNTIiwiQ1VSUkVOQ1lfQ09ERSIsIk5FWFRfUFVCTElDX0NVUlJFTkNZX0NPREUiLCJmZXRjaFdhbGxldEJhbGFuY2VzIiwiYWRtaW5YUlAiLCJnZXRYUlBCYWxhbmNlIiwidHJlYXN1cnlUWlMiLCJnZXRUb2tlbkJhbGFuY2UiLCJ0b0ZpeGVkIiwiZXJyb3IiLCJjb25zb2xlIiwiZmV0Y2hUcmFuc2FjdGlvbnMiLCJhZG1pblR4cyIsImdldEFjY291bnRUcmFuc2FjdGlvbnMiLCJ0cmVhc3VyeVR4cyIsImFsbFR4cyIsInJlc3VsdCIsImZvcm1hdHRlZFR4cyIsIm1hcCIsInR4IiwidHJhbnNhY3Rpb24iLCJtZXRhIiwiaGFzaCIsIkhhc2giLCJ0eXBlIiwiZ2V0VHJhbnNhY3Rpb25UeXBlIiwiYW1vdW50IiwiZ2V0VHJhbnNhY3Rpb25BbW91bnQiLCJmcm9tIiwiQWNjb3VudCIsInRvIiwiRGVzdGluYXRpb24iLCJzdGF0dXMiLCJUcmFuc2FjdGlvblJlc3VsdCIsInRpbWVzdGFtcCIsImZvcm1hdFRpbWVzdGFtcCIsImRhdGUiLCJzbGljZSIsInByZXYiLCJsZW5ndGgiLCJ0b1N0cmluZyIsImNhbGN1bGF0ZVN0YXRzIiwidHJlYXN1cnlCYWxhbmNlIiwiTWF0aCIsIm1heCIsInNldHVwUmVhbFRpbWVNb25pdG9yaW5nIiwic3Vic2NyaWJlVG9UcmFuc2FjdGlvbnMiLCJuZXdUeCIsInVuc3Vic2NyaWJlRnJvbVRyYW5zYWN0aW9ucyIsImZldGNoSW5pdGlhbERhdGEiLCJQcm9taXNlIiwiYWxsIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJyZWZyZXNoRGF0YSIsIlRyYW5zYWN0aW9uVHlwZSIsIkFtb3VudCIsInBhcnNlSW50IiwidmFsdWUiLCJjdXJyZW5jeSIsInJpcHBsZVRpbWUiLCJ1bml4VGltZSIsIkRhdGUiLCJub3ciLCJkaWZmTXMiLCJnZXRUaW1lIiwiZGlmZk1pbnMiLCJmbG9vciIsInRvTG9jYWxlRGF0ZVN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useRealTimeData.ts\n"));

/***/ })

});